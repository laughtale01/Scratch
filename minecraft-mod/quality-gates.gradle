// Quality Gates Configuration for Minecraft Collaboration Mod
// This file defines multi-level quality gates for ensuring code quality

// Quality Gate Level 1: Basic Checks (Required for every commit)
task qualityGateLevel1 {
    dependsOn unitTest
    description = 'Level 1 Quality Gate - Unit tests and basic checks'
    
    doLast {
        println "âœ… Level 1 Quality Gate: Unit Tests"
        def testResults = tasks.unitTest.testResultsDir.get().asFile
        if (testResults.exists()) {
            def xmlFiles = fileTree(testResults).matching { include '**/*.xml' }
            def totalTests = 0
            def failedTests = 0
            
            xmlFiles.each { file ->
                def xml = new XmlSlurper().parse(file)
                totalTests += xml.@tests.toInteger()
                failedTests += xml.@failures.toInteger() + xml.@errors.toInteger()
            }
            
            def successRate = totalTests > 0 ? ((totalTests - failedTests) / totalTests * 100) : 0
            println "ğŸ“Š Test Results: ${totalTests - failedTests}/${totalTests} passed (${String.format('%.1f', successRate)}%)"
            
            if (successRate < 85.0) {
                throw new GradleException("âŒ Quality Gate Level 1 FAILED: Test success rate ${String.format('%.1f', successRate)}% is below threshold (85.0%)")
            }
            
            println "âœ… Quality Gate Level 1 PASSED: Test success rate meets requirement"
        }
    }
}

// Quality Gate Level 2: Integration and Coverage (Required for PR)
task qualityGateLevel2 {
    dependsOn qualityGateLevel1, safeIntegrationTest
    description = 'Level 2 Quality Gate - Integration tests and coverage'
    
    doLast {
        println "âœ… Level 2 Quality Gate: Integration Tests & Coverage"
        
        // Check integration test results
        def integrationResults = tasks.safeIntegrationTest.testResultsDir.get().asFile
        if (integrationResults.exists()) {
            def xmlFiles = fileTree(integrationResults).matching { include '**/*.xml' }
            def totalTests = 0
            def failedTests = 0
            
            xmlFiles.each { file ->
                def xml = new XmlSlurper().parse(file)
                totalTests += xml.@tests.toInteger()
                failedTests += xml.@failures.toInteger() + xml.@errors.toInteger()
            }
            
            def successRate = totalTests > 0 ? ((totalTests - failedTests) / totalTests * 100) : 0
            println "ğŸ“Š Integration Test Results: ${totalTests - failedTests}/${totalTests} passed (${String.format('%.1f', successRate)}%)"
            
            if (successRate < 80.0) {
                throw new GradleException("âŒ Quality Gate Level 2 FAILED: Integration test success rate ${String.format('%.1f', successRate)}% is below threshold (80.0%)")
            }
        }
        
        // Check code coverage
        def jacocoReportFile = file("$buildDir/reports/jacoco/test/jacocoTestReport.xml")
        if (jacocoReportFile.exists()) {
            def xml = new XmlSlurper().parse(jacocoReportFile)
            def coverage = xml.counter.find { it.@type == 'LINE' }
            if (coverage) {
                def covered = coverage.@covered.toDouble()
                def missed = coverage.@missed.toDouble()
                def total = covered + missed
                def coveragePercent = total > 0 ? (covered / total * 100) : 0
                
                println "ğŸ“Š Code Coverage: ${String.format('%.1f', coveragePercent)}%"
                
                if (coveragePercent < 70.0) {
                    println "âš ï¸  Warning: Code coverage ${String.format('%.1f', coveragePercent)}% is below recommended threshold (70.0%)"
                }
            }
        }
        
        println "âœ… Quality Gate Level 2 PASSED"
    }
}

// Quality Gate Level 3: Full Quality Audit (Required for release)
task qualityGateLevel3 {
    dependsOn qualityGateLevel2
    // Note: Code quality checks run separately to avoid dependency issues
    description = 'Level 3 Quality Gate - Full quality audit'
    
    doLast {
        println "âœ… Level 3 Quality Gate: Full Quality Audit"
        
        // Check Checkstyle results
        def checkstyleReport = file("$buildDir/reports/checkstyle/main.xml")
        if (checkstyleReport.exists()) {
            def xml = new XmlSlurper().parse(checkstyleReport)
            def errorCount = xml.file.error.size()
            println "ğŸ“Š Checkstyle: ${errorCount} issues found"
            
            if (errorCount > 50) { // Allow some warnings initially
                println "âš ï¸  Warning: Checkstyle found ${errorCount} issues (threshold: 50)"
            }
        }
        
        // Check PMD results
        def pmdReport = file("$buildDir/reports/pmd/main.xml")
        if (pmdReport.exists()) {
            def xml = new XmlSlurper().parse(pmdReport)
            def violationCount = xml.file.violation.size()
            println "ğŸ“Š PMD: ${violationCount} violations found"
            
            if (violationCount > 20) {
                println "âš ï¸  Warning: PMD found ${violationCount} violations (threshold: 20)"
            }
        }
        
        // Check SpotBugs results
        def spotbugsReport = file("$buildDir/reports/spotbugs/main.xml")
        if (spotbugsReport.exists()) {
            def xml = new XmlSlurper().parse(spotbugsReport)
            def bugCount = xml.BugInstance.size()
            println "ğŸ“Š SpotBugs: ${bugCount} potential bugs found"
            
            if (bugCount > 10) {
                println "âš ï¸  Warning: SpotBugs found ${bugCount} potential bugs (threshold: 10)"
            }
        }
        
        println "âœ… Quality Gate Level 3 PASSED"
    }
}

// Educational Quality Gate: Specific checks for educational software
task educationalQualityGate {
    description = 'Educational Quality Gate - Checks for educational appropriateness'
    
    doLast {
        println "âœ… Educational Quality Gate: Checking educational requirements"
        
        // Check for security features
        def securityClasses = fileTree('src/main/java').matching {
            include '**/security/**/*.java'
        }.files.size()
        
        println "ğŸ“Š Security classes: ${securityClasses}"
        if (securityClasses < 5) {
            println "âš ï¸  Warning: Limited security implementation detected"
        }
        
        // Check for documentation
        def javaFiles = fileTree('src/main/java').matching {
            include '**/*.java'
        }.files
        
        def documentedClasses = 0
        javaFiles.each { file ->
            def content = file.text
            if (content.contains('/**') && content.contains('*/')) {
                documentedClasses++
            }
        }
        
        def documentationRate = javaFiles.size() > 0 ? (documentedClasses / javaFiles.size() * 100) : 0
        println "ğŸ“Š Documentation coverage: ${String.format('%.1f', documentationRate)}%"
        
        if (documentationRate < 60.0) {
            println "âš ï¸  Warning: Documentation coverage ${String.format('%.1f', documentationRate)}% is below recommended threshold (60.0%)"
        }
        
        println "âœ… Educational Quality Gate PASSED"
    }
}

// Comprehensive quality check with all gates
task comprehensiveQualityCheck {
    dependsOn qualityGateLevel3, educationalQualityGate
    description = 'Run all quality gates for comprehensive check'
    
    doLast {
        println ""
        println "ğŸ‰ ALL QUALITY GATES PASSED!"
        println "ğŸ“ˆ Project meets all quality standards for educational software"
        println ""
    }
}