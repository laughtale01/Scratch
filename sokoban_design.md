# 倉庫番ゲーム設計書（Minecraft連携版）

## 1. ゲーム概要
Scratchから制御するMinecraft倉庫番ゲーム

## 2. ブロック定義
- **壁**: stone_bricks（石レンガ）
- **床**: smooth_stone（滑らかな石）
- **ゴール**: gold_block（金ブロック）の上に smooth_stone
- **箱（通常）**: redstone_block（レッドストーンブロック）
- **箱（ゴール上）**: emerald_block（エメラルドブロック）
- **プレイヤー**: diamond_block（ダイヤモンドブロック）

## 3. 変数定義

### プレイヤー位置
- `playerX`: プレイヤーのX座標
- `playerY`: プレイヤーのY座標（マップ上のY、Minecraft座標ではZ）

### マップサイズ
- `mapWidth`: マップの幅（例: 10）
- `mapHeight`: マップの高さ（例: 10）

### ゲーム状態
- `gameState`: ゲームの状態（0=未開始, 1=プレイ中, 2=クリア）
- `moveCount`: 移動回数
- `pushCount`: 箱を押した回数

### 一時変数
- `tempX`: 一時的なX座標
- `tempY`: 一時的なY座標
- `tempIndex`: 一時的なインデックス
- `checkX`: チェック用X座標
- `checkY`: チェック用Y座標

## 4. リスト定義

### ステージデータ
- `stageData`: ステージのマップデータ（1次元配列）
  - 0: 壁（wall）
  - 1: 床（floor）
  - 2: ゴール（goal）
  - 3: 箱（box）
  - 4: プレイヤー初期位置（player）
  - 5: 箱+ゴール（box on goal）

### 箱の位置
- `boxesX`: 箱のX座標リスト
- `boxesY`: 箱のY座標リスト

### ゴールの位置
- `goalsX`: ゴールのX座標リスト
- `goalsY`: ゴールのY座標リスト

## 5. サンプルステージ（10x10）

```
# # # # # # # # # #
# . . . # . . . . #
# . B . # . G . . #
# . . . . . . . . #
# # # # . # # # # #
# . . . . . . . . #
# . G . # . B . . #
# . . . # . . . P #
# . . . . . . . . #
# # # # # # # # # #
```

凡例:
- `#`: 壁
- `.`: 床
- `G`: ゴール
- `B`: 箱
- `P`: プレイヤー
- `X`: 箱（ゴール上）

ステージデータ（1次元配列、100要素）:
```
0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,1,1,1,1,0,
0,1,3,1,0,1,2,1,1,0,
0,1,1,1,1,1,1,1,1,0,
0,0,0,0,1,0,0,0,0,0,
0,1,1,1,1,1,1,1,1,0,
0,1,2,1,0,1,3,1,1,0,
0,1,1,1,0,1,1,1,4,0,
0,1,1,1,1,1,1,1,1,0,
0,0,0,0,0,0,0,0,0,0
```

## 6. 処理フロー

### 6.1 初期化処理（緑の旗がクリックされたとき）
1. ゲーム状態を0（未開始）に設定
2. ステージデータをリストに格納
3. マップサイズを設定（10x10）
4. ステージデータを解析して配置
   - 箱の位置をboxesX, boxesYに格納
   - ゴールの位置をgoalsX, goalsYに格納
   - プレイヤーの初期位置を設定
5. Minecraftにマップを描画
6. ゲーム状態を1（プレイ中）に設定

### 6.2 描画処理
1. 指定座標（baseX=0, baseY=0, baseZ=0）を基準
2. マップの各マスを走査
   - Y座標: Minecraft Y=0 (実際は-60)
   - X座標: マップX座標をそのまま使用
   - Z座標: マップY座標をそのまま使用
3. 各マスのブロックを設置
   - 壁: stone_bricks
   - 床: smooth_stone
   - ゴール: gold_block + smooth_stone（上）
   - 箱: redstone_block
   - 箱（ゴール上）: emerald_block
   - プレイヤー: diamond_block

### 6.3 キー入力処理
- ↑キー: プレイヤーを上に移動（Y-1）
- ↓キー: プレイヤーを下に移動（Y+1）
- ←キー: プレイヤーを左に移動（X-1）
- →キー: プレイヤーを右に移動（X+1）
- スペースキー: ステージリセット

### 6.4 移動処理
1. 移動先座標を計算（tempX, tempY）
2. 移動先が壁かチェック
   - 壁なら移動キャンセル
3. 移動先に箱があるかチェック
   - 箱があれば箱押し処理へ
   - なければプレイヤー移動
4. プレイヤー位置を更新
5. 画面を再描画
6. クリア判定

### 6.5 箱押し処理
1. 箱の先の座標を計算（checkX, checkY）
2. 箱の先が壁かチェック
   - 壁なら移動キャンセル
3. 箱の先に別の箱があるかチェック
   - あれば移動キャンセル
4. 箱の位置を更新
5. プレイヤー位置を更新
6. 押した回数をカウント
7. 画面を再描画
8. クリア判定

### 6.6 クリア判定処理
1. すべての箱について繰り返し
2. 箱の座標がゴール座標と一致するかチェック
3. すべて一致すればクリア
   - ゲーム状態を2（クリア）に設定
   - クリアメッセージを表示

## 7. カスタムブロック（関数）定義

### getMapValue(x, y)
- マップ座標(x, y)のステージデータ値を取得
- インデックス = y * mapWidth + x
- stageDataリストから値を取得して返す

### setMapValue(x, y, value)
- マップ座標(x, y)のステージデータ値を設定
- インデックス = y * mapWidth + x
- stageDataリストの値を更新

### isWall(x, y)
- 座標(x, y)が壁（0）かどうかを判定
- getMapValue(x, y)を使用
- 壁なら1、そうでなければ0を返す

### findBox(x, y)
- 座標(x, y)に箱があるかチェック
- boxesX, boxesYリストを走査
- 見つかればインデックス+1、なければ0を返す

### isGoal(x, y)
- 座標(x, y)がゴールかどうかを判定
- goalsX, goalsYリストを走査
- ゴールなら1、そうでなければ0を返す

### movePlayer(dx, dy)
- プレイヤーを方向(dx, dy)に移動
- 移動先座標 = (playerX + dx, playerY + dy)
- 移動先が壁でないかチェック
- 移動先に箱があれば pushBox(dx, dy) を呼び出し
- なければプレイヤー位置を更新
- 移動回数をカウント

### pushBox(dx, dy)
- 箱を方向(dx, dy)に押す
- 箱の位置 = (playerX + dx, playerY + dy)
- 箱の先 = (playerX + dx*2, playerY + dy*2)
- 箱の先が壁 または 別の箱なら移動キャンセル
- そうでなければ箱とプレイヤーの位置を更新
- 押した回数をカウント

### drawMap()
- Minecraftにマップ全体を描画
- まず全体をクリア（clearArea）
- 各マスを走査して対応するブロックを設置
- プレイヤー位置にdiamond_blockを設置
- 箱の位置にブロックを設置（ゴール上ならemerald_block）

### checkClear()
- すべての箱がゴール上にあるかチェック
- boxesX, boxesYリストを走査
- 各箱がgoalsX, goalsYのいずれかと一致するかチェック
- すべて一致すればクリア

## 8. Minecraft座標系

- Scratch マップX → Minecraft X
- Scratch マップY → Minecraft Z
- Minecraft Y = 0（実際は -60）

基準座標:
- baseX = 0
- baseY = 0
- baseZ = 0

実際の設置座標:
- Minecraft X = baseX + マップX
- Minecraft Y = baseY + 0 (Scratchでは0、実際には-60に変換)
- Minecraft Z = baseZ + マップY

## 9. 実装の優先順位

1. ステージデータ定義と初期化
2. 描画処理（drawMap）
3. キー入力処理
4. 移動処理（movePlayer）
5. 箱押し処理（pushBox）
6. クリア判定（checkClear）
7. リセット処理
