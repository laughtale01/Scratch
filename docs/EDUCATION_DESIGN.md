# æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ©Ÿèƒ½ è©³ç´°è¨­è¨ˆæ›¸

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ](#ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ )
3. [èª²é¡Œã‚·ã‚¹ãƒ†ãƒ ](#èª²é¡Œã‚·ã‚¹ãƒ†ãƒ )
4. [é€²æ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ](#é€²æ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ )
5. [ãƒãƒƒã‚¸ãƒ»é”æˆã‚·ã‚¹ãƒ†ãƒ ](#ãƒãƒƒã‚¸é”æˆã‚·ã‚¹ãƒ†ãƒ )
6. [ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ](#ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ)
7. [ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«](#ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«)
8. [UI/UXè¨­è¨ˆ](#uiuxè¨­è¨ˆ)
9. [å®Ÿè£…ã‚¬ã‚¤ãƒ‰](#å®Ÿè£…ã‚¬ã‚¤ãƒ‰)
10. [ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¬ã‚¤ãƒ‰](#ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¬ã‚¤ãƒ‰)

---

## æ¦‚è¦

### æ•™è‚²æ©Ÿèƒ½ã®ç›®çš„

1. **æ®µéšçš„å­¦ç¿’**: åˆå¿ƒè€…ã‹ã‚‰ä¸Šç´šè€…ã¾ã§å¯¾å¿œã—ãŸã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—ã®å­¦ç¿’
2. **è‡ªå‹•è©•ä¾¡**: å­¦ç¿’è€…ã®æ“ä½œã‚’è‡ªå‹•çš„ã«è©•ä¾¡ã—ã€å³åº§ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
3. **é€²æ—å¯è¦–åŒ–**: å­¦ç¿’ã®é€²ã¿å…·åˆã‚’åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
4. **ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ç¶­æŒ**: ãƒãƒƒã‚¸ã‚„ãƒã‚¤ãƒ³ãƒˆã§ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
5. **æ•™å¸«æ”¯æ´**: èª²é¡Œç®¡ç†ã€é€²æ—ç¢ºèªã€è©•ä¾¡ã®åŠ¹ç‡åŒ–

### ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç®¡ç†å±¤                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tutorial    â”‚ Challenge   â”‚ Progress    â”‚ Badge        â”‚
â”‚ System      â”‚ System      â”‚ Tracker     â”‚ System       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚             â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ValidationEngine                          â”‚
â”‚    å­¦ç¿’è€…ã®æ“ä½œã‚’æ¤œè¨¼ã—ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›             â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                DataPersistenceLayer                      â”‚
â”‚          JSON / SQLite / PostgreSQL                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ 

### è¨­è¨ˆç›®æ¨™

- åˆå¿ƒè€…ã§ã‚‚è¿·ã‚ãšé€²ã‚ã‚‰ã‚Œã‚‹ã‚¬ã‚¤ãƒ‰ä»˜ãå­¦ç¿’
- å„ã‚¹ãƒ†ãƒƒãƒ—ã®è‡ªå‹•æ¤œè¨¼
- ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¿œã˜ãŸãƒ’ãƒ³ãƒˆæä¾›
- æ®µéšçš„ãªé›£æ˜“åº¦ä¸Šæ˜‡

### ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«æ§‹é€ 

#### Tutorial ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

```java
public class Tutorial {
    private String tutorialId;           // ä¸€æ„è­˜åˆ¥å­
    private String title;                // ã‚¿ã‚¤ãƒˆãƒ«
    private String description;          // èª¬æ˜
    private DifficultyLevel difficulty;  // é›£æ˜“åº¦
    private int estimatedMinutes;        // æƒ³å®šæ‰€è¦æ™‚é–“
    private List<String> prerequisites;  // å‰æãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ID
    private List<TutorialStep> steps;    // ã‚¹ãƒ†ãƒƒãƒ—ãƒªã‚¹ãƒˆ
    private TutorialMetadata metadata;   // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿

    // ã‚²ãƒƒã‚¿ãƒ¼ãƒ»ã‚»ãƒƒã‚¿ãƒ¼
}

public enum DifficultyLevel {
    BEGINNER(1, "åˆç´š", "ğŸŸ¢"),
    INTERMEDIATE(2, "ä¸­ç´š", "ğŸŸ¡"),
    ADVANCED(3, "ä¸Šç´š", "ğŸ”´"),
    EXPERT(4, "ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ", "âš«");

    private final int level;
    private final String displayName;
    private final String emoji;
}

public class TutorialStep {
    private int stepId;                  // ã‚¹ãƒ†ãƒƒãƒ—ç•ªå·
    private String title;                // ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¤ãƒˆãƒ«
    private String instruction;          // æŒ‡ç¤ºæ–‡
    private String hint;                 // ãƒ’ãƒ³ãƒˆ
    private List<String> imageUrls;      // èª¬æ˜ç”»åƒURL
    private ValidationRule validation;   // æ¤œè¨¼ãƒ«ãƒ¼ãƒ«
    private StepReward reward;           // å ±é…¬
    private int maxAttempts;             // æœ€å¤§è©¦è¡Œå›æ•°ï¼ˆ0=ç„¡åˆ¶é™ï¼‰
}

public class ValidationRule {
    private ValidationType type;         // æ¤œè¨¼ã‚¿ã‚¤ãƒ—
    private Map<String, Object> params;  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

    public enum ValidationType {
        CHAT_MESSAGE,          // ãƒãƒ£ãƒƒãƒˆé€ä¿¡
        BLOCK_PLACED,          // ãƒ–ãƒ­ãƒƒã‚¯é…ç½®
        BLOCK_PATTERN,         // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        ENTITY_SUMMONED,       // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å¬å–š
        PLAYER_POSITION,       // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®
        ITEM_IN_INVENTORY,     // ã‚¢ã‚¤ãƒ†ãƒ æ‰€æŒ
        CODE_STRUCTURE,        // Scratchã‚³ãƒ¼ãƒ‰æ§‹é€ 
        CUSTOM_SCRIPT          // ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
    }
}

public class StepReward {
    private int points;                  // ç²å¾—ãƒã‚¤ãƒ³ãƒˆ
    private String badgeId;              // ç²å¾—ãƒãƒƒã‚¸IDï¼ˆoptionalï¼‰
    private String message;              // å ±é…¬ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
}
```

### ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä¾‹ï¼ˆJSONï¼‰

```json
{
  "tutorialId": "beginner_001_hello_world",
  "title": "ã¯ã˜ã‚ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼šHello World",
  "description": "Scratchã‚’ä½¿ã£ã¦Minecraftã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã£ã¦ã¿ã‚ˆã†",
  "difficulty": "BEGINNER",
  "estimatedMinutes": 10,
  "prerequisites": [],
  "metadata": {
    "author": "MinecraftEdu Team",
    "version": "1.0",
    "tags": ["åˆå¿ƒè€…", "ãƒãƒ£ãƒƒãƒˆ", "åŸºæœ¬"],
    "thumbnailUrl": "/assets/tutorials/beginner_001.png"
  },
  "steps": [
    {
      "stepId": 1,
      "title": "Scratchã‚’é–‹ã“ã†",
      "instruction": "ãƒ–ãƒ©ã‚¦ã‚¶ã§Scratchã®ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„ã€‚å·¦å´ã«ç·‘è‰²ã®ã€ŒMinecraftã€ã‚«ãƒ†ã‚´ãƒªãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚",
      "hint": "ã‚‚ã—ã€ŒMinecraftã€ã‚«ãƒ†ã‚´ãƒªãŒè¦‹ãˆãªã„å ´åˆã¯ã€ã€Œæ‹¡å¼µæ©Ÿèƒ½ã‚’è¿½åŠ ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¿½åŠ ã—ã¦ãã ã•ã„ã€‚",
      "imageUrls": ["/assets/tutorials/scratch_interface.png"],
      "validation": {
        "type": "MANUAL_CHECK",
        "params": {}
      },
      "reward": {
        "points": 5,
        "message": "ã‚ˆãã§ãã¾ã—ãŸï¼Scratchã®æº–å‚™ãŒã§ãã¾ã—ãŸã€‚"
      },
      "maxAttempts": 0
    },
    {
      "stepId": 2,
      "title": "Minecraftã«æ¥ç¶šã—ã‚ˆã†",
      "instruction": "ã€ŒMinecraftã«æ¥ç¶šã€ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã€ç·‘ã®æ——ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
      "hint": "ãƒ›ã‚¹ãƒˆã¯ã€Œlocalhostã€ã€ãƒãƒ¼ãƒˆã¯ã€Œ14711ã€ã®ã¾ã¾ã§OKã§ã™ã€‚",
      "imageUrls": ["/assets/tutorials/connect_block.png"],
      "validation": {
        "type": "CONNECTION_ESTABLISHED",
        "params": {
          "timeout": 30000
        }
      },
      "reward": {
        "points": 10,
        "badgeId": "connected",
        "message": "æ¥ç¶šæˆåŠŸï¼Minecraftã¨é€šä¿¡ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚"
      },
      "maxAttempts": 5
    },
    {
      "stepId": 3,
      "title": "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚ã†",
      "instruction": "ã€Œãƒãƒ£ãƒƒãƒˆã§è¨€ã†ã€ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã£ã¦ã€ã€ŒHello, Minecraft!ã€ã¨ã„ã†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚",
      "hint": "ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã¤ãªã’ã¦ã€ãƒ†ã‚­ã‚¹ãƒˆæ¬„ã«ã€ŒHello, Minecraft!ã€ã¨å…¥åŠ›ã—ã¦ã­ã€‚",
      "imageUrls": ["/assets/tutorials/chat_block.png"],
      "validation": {
        "type": "CHAT_MESSAGE",
        "params": {
          "expectedText": "Hello, Minecraft!",
          "caseSensitive": false
        }
      },
      "reward": {
        "points": 15,
        "badgeId": "first_chat",
        "message": "ã‚„ã£ãŸã­ï¼åˆã‚ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡æˆåŠŸã§ã™ï¼ğŸ‰"
      },
      "maxAttempts": 3
    },
    {
      "stepId": 4,
      "title": "ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç½®ã“ã†",
      "instruction": "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›®ã®å‰ï¼ˆç›¸å¯¾åº§æ¨™ ~0 ~1 ~2ï¼‰ã«çŸ³ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç½®ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚",
      "hint": "ã€Œãƒ–ãƒ­ãƒƒã‚¯ã‚’ç½®ãã€ãƒ–ãƒ­ãƒƒã‚¯ã§ã€åº§æ¨™ã‚’ã€Œ~0ã€ã€Œ~1ã€ã€Œ~2ã€ã«è¨­å®šã—ã€ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã‚’ã€Œstoneã€ã«é¸æŠã—ã¦ãã ã•ã„ã€‚",
      "imageUrls": ["/assets/tutorials/place_block.png"],
      "validation": {
        "type": "BLOCK_PLACED",
        "params": {
          "blockType": "minecraft:stone",
          "relativePosition": [0, 1, 2],
          "tolerance": 0
        }
      },
      "reward": {
        "points": 20,
        "badgeId": "first_builder",
        "message": "ã™ã”ã„ï¼åˆã‚ã¦ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç½®ãã¾ã—ãŸï¼å»ºç¯‰å®¶ã¸ã®é“ãŒå§‹ã¾ã‚Šã¾ã™ã€‚"
      },
      "maxAttempts": 5
    }
  ]
}
```

### TutorialManagerï¼ˆJavaå®Ÿè£…ï¼‰

```java
public class TutorialManager {

    private final Map<String, Tutorial> tutorials;
    private final Map<String, TutorialProgress> userProgress;
    private final ValidationEngine validationEngine;
    private final EventBroadcaster broadcaster;

    public TutorialManager(
        TutorialRepository repository,
        ValidationEngine validationEngine,
        EventBroadcaster broadcaster
    ) {
        this.tutorials = repository.loadAll();
        this.userProgress = new ConcurrentHashMap<>();
        this.validationEngine = validationEngine;
        this.broadcaster = broadcaster;
    }

    /**
     * ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«é–‹å§‹
     */
    public TutorialStartResult startTutorial(
        ClientSession session,
        String tutorialId
    ) {
        Tutorial tutorial = tutorials.get(tutorialId);
        if (tutorial == null) {
            return TutorialStartResult.error("ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        }

        // å‰ææ¡ä»¶ãƒã‚§ãƒƒã‚¯
        for (String prerequisiteId : tutorial.getPrerequisites()) {
            if (!isCompleted(session.getClientId(), prerequisiteId)) {
                return TutorialStartResult.error(
                    "å…ˆã«ã€Œ" + tutorials.get(prerequisiteId).getTitle() + "ã€ã‚’å®Œäº†ã—ã¦ãã ã•ã„"
                );
            }
        }

        // é€²æ—åˆæœŸåŒ–
        TutorialProgress progress = new TutorialProgress(
            session.getClientId(),
            tutorialId,
            tutorial.getSteps().size()
        );
        progress.setCurrentStep(1);
        userProgress.put(getProgressKey(session.getClientId(), tutorialId), progress);

        // æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿”ã™
        TutorialStep firstStep = tutorial.getSteps().get(0);

        broadcaster.sendToClient(session, new TutorialStepMessage(firstStep));

        return TutorialStartResult.success(tutorial, firstStep);
    }

    /**
     * ã‚¹ãƒ†ãƒƒãƒ—æ¤œè¨¼
     */
    public StepValidationResult validateStep(
        ClientSession session,
        String tutorialId,
        int stepId,
        Object action
    ) {
        Tutorial tutorial = tutorials.get(tutorialId);
        TutorialProgress progress = userProgress.get(
            getProgressKey(session.getClientId(), tutorialId)
        );

        if (progress == null) {
            return StepValidationResult.error("ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“");
        }

        if (progress.getCurrentStep() != stepId) {
            return StepValidationResult.error("é †ç•ªã«ã‚¹ãƒ†ãƒƒãƒ—ã‚’é€²ã‚ã¦ãã ã•ã„");
        }

        TutorialStep step = tutorial.getSteps().get(stepId - 1);

        // æ¤œè¨¼å®Ÿè¡Œ
        ValidationResult result = validationEngine.validate(
            step.getValidation(),
            action
        );

        if (result.isValid()) {
            // ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†
            progress.completeStep(stepId);
            progress.addPoints(step.getReward().getPoints());

            // ãƒãƒƒã‚¸ä»˜ä¸
            if (step.getReward().getBadgeId() != null) {
                progress.addBadge(step.getReward().getBadgeId());
            }

            // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸
            if (stepId < tutorial.getSteps().size()) {
                progress.setCurrentStep(stepId + 1);
                TutorialStep nextStep = tutorial.getSteps().get(stepId);
                broadcaster.sendToClient(session, new TutorialStepMessage(nextStep));

                return StepValidationResult.success(
                    step.getReward().getMessage(),
                    nextStep
                );
            } else {
                // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«å®Œäº†
                progress.setCompleted(true);
                broadcaster.sendToClient(session, new TutorialCompletedMessage(tutorial));

                return StepValidationResult.tutorialCompleted(
                    "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã€Œ" + tutorial.getTitle() + "ã€ã‚’å®Œäº†ã—ã¾ã—ãŸï¼"
                );
            }
        } else {
            // å¤±æ•—
            progress.incrementAttempts(stepId);

            // ãƒ’ãƒ³ãƒˆè¡¨ç¤ºåˆ¤å®šï¼ˆ3å›å¤±æ•—ã—ãŸã‚‰ãƒ’ãƒ³ãƒˆï¼‰
            if (progress.getAttempts(stepId) >= 3 && step.getHint() != null) {
                return StepValidationResult.failed(
                    result.getMessage(),
                    step.getHint()
                );
            }

            return StepValidationResult.failed(result.getMessage(), null);
        }
    }

    /**
     * ãƒ’ãƒ³ãƒˆå–å¾—
     */
    public String getHint(String tutorialId, int stepId) {
        Tutorial tutorial = tutorials.get(tutorialId);
        if (tutorial != null && stepId <= tutorial.getSteps().size()) {
            return tutorial.getSteps().get(stepId - 1).getHint();
        }
        return null;
    }

    /**
     * ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä¸€è¦§å–å¾—
     */
    public List<TutorialSummary> getTutorialList(ClientSession session) {
        return tutorials.values().stream()
            .map(t -> new TutorialSummary(
                t.getTutorialId(),
                t.getTitle(),
                t.getDescription(),
                t.getDifficulty(),
                t.getEstimatedMinutes(),
                isCompleted(session.getClientId(), t.getTutorialId()),
                canStart(session.getClientId(), t)
            ))
            .collect(Collectors.toList());
    }

    private boolean isCompleted(String userId, String tutorialId) {
        TutorialProgress progress = userProgress.get(getProgressKey(userId, tutorialId));
        return progress != null && progress.isCompleted();
    }

    private boolean canStart(String userId, Tutorial tutorial) {
        return tutorial.getPrerequisites().stream()
            .allMatch(prereq -> isCompleted(userId, prereq));
    }

    private String getProgressKey(String userId, String tutorialId) {
        return userId + ":" + tutorialId;
    }
}
```

### ValidationEngine

```java
public class ValidationEngine {

    private final MinecraftServer mcServer;

    public ValidationResult validate(ValidationRule rule, Object action) {
        switch (rule.getType()) {
            case CHAT_MESSAGE:
                return validateChatMessage(rule, (ChatAction) action);

            case BLOCK_PLACED:
                return validateBlockPlaced(rule, (BlockPlaceAction) action);

            case BLOCK_PATTERN:
                return validateBlockPattern(rule, (BlockPatternAction) action);

            case ENTITY_SUMMONED:
                return validateEntitySummoned(rule, (EntitySummonAction) action);

            // ... ãã®ä»–ã®ã‚¿ã‚¤ãƒ—

            default:
                return ValidationResult.invalid("æœªå¯¾å¿œã®æ¤œè¨¼ã‚¿ã‚¤ãƒ—ã§ã™");
        }
    }

    private ValidationResult validateChatMessage(ValidationRule rule, ChatAction action) {
        String expectedText = (String) rule.getParams().get("expectedText");
        boolean caseSensitive = (boolean) rule.getParams().getOrDefault("caseSensitive", false);

        String actualText = action.getMessage();
        boolean matches = caseSensitive
            ? actualText.equals(expectedText)
            : actualText.equalsIgnoreCase(expectedText);

        if (matches) {
            return ValidationResult.valid();
        } else {
            return ValidationResult.invalid(
                String.format(
                    "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•ã„ã¾ã™ã€‚ã€Œ%sã€ã¨é€ä¿¡ã—ã¦ãã ã•ã„ã€‚",
                    expectedText
                )
            );
        }
    }

    private ValidationResult validateBlockPlaced(ValidationRule rule, BlockPlaceAction action) {
        String expectedBlockType = (String) rule.getParams().get("blockType");
        List<Integer> relativePos = (List<Integer>) rule.getParams().get("relativePosition");
        int tolerance = (int) rule.getParams().getOrDefault("tolerance", 0);

        // ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
        if (!action.getBlockType().equals(expectedBlockType)) {
            return ValidationResult.invalid(
                String.format(
                    "ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ãŒé•ã„ã¾ã™ã€‚ã€Œ%sã€ã‚’ç½®ã„ã¦ãã ã•ã„ã€‚",
                    expectedBlockType
                )
            );
        }

        // åº§æ¨™ãƒã‚§ãƒƒã‚¯ï¼ˆç›¸å¯¾åº§æ¨™ï¼‰
        if (relativePos != null) {
            int dx = Math.abs(action.getRelativeX() - relativePos.get(0));
            int dy = Math.abs(action.getRelativeY() - relativePos.get(1));
            int dz = Math.abs(action.getRelativeZ() - relativePos.get(2));

            if (dx <= tolerance && dy <= tolerance && dz <= tolerance) {
                return ValidationResult.valid();
            } else {
                return ValidationResult.invalid(
                    String.format(
                        "ä½ç½®ãŒé•ã„ã¾ã™ã€‚ç›¸å¯¾åº§æ¨™ ~%d ~%d ~%d ã«ç½®ã„ã¦ãã ã•ã„ã€‚",
                        relativePos.get(0), relativePos.get(1), relativePos.get(2)
                    )
                );
            }
        }

        return ValidationResult.valid();
    }

    // ... ãã®ä»–ã®æ¤œè¨¼ãƒ¡ã‚½ãƒƒãƒ‰
}
```

---

## èª²é¡Œã‚·ã‚¹ãƒ†ãƒ 

### èª²é¡Œã‚¿ã‚¤ãƒ—

| ã‚¿ã‚¤ãƒ— | èª¬æ˜ | è©•ä¾¡åŸºæº– | ä¾‹ |
|-------|------|---------|---|
| **å»ºç¯‰èª²é¡Œ** | æŒ‡å®šã•ã‚ŒãŸæ§‹é€ ã‚’å»ºç¯‰ | æ§‹é€ ä¸€è‡´åº¦ã€ãƒ–ãƒ­ãƒƒã‚¯æ•°ã€ç¾çš„è¦ç´  | ã€Œ5x5ã®å®¶ã‚’ä½œã‚ã†ã€ |
| **ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°èª²é¡Œ** | åŠ¹ç‡çš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã | ã‚³ãƒ¼ãƒ‰è¡Œæ•°ã€ãƒ–ãƒ­ãƒƒã‚¯ä½¿ç”¨æ•°ã€ãƒ«ãƒ¼ãƒ—æ´»ç”¨ | ã€Œ10è¡Œä»¥å†…ã§éšæ®µã‚’ä½œã‚ã†ã€ |
| **æ¢ç´¢èª²é¡Œ** | ç‰¹å®šã®æ¡ä»¶ã‚’æº€ãŸã™ | é”æˆ/æœªé”æˆã€æ‰€è¦æ™‚é–“ | ã€Œæ‘ã‚’è¦‹ã¤ã‘ã‚ˆã†ã€ |
| **å‰µé€ èª²é¡Œ** | ãƒ†ãƒ¼ãƒã«æ²¿ã£ãŸä½œå“ | å‰µé€ æ€§ã€æŠ€è¡“åŠ›ï¼ˆæ•™å¸«è©•ä¾¡ï¼‰ | ã€Œæœªæ¥ã®éƒ½å¸‚ã‚’ä½œã‚ã†ã€ |
| **å”åƒèª²é¡Œ** | ãƒãƒ¼ãƒ ã§å–ã‚Šçµ„ã‚€ | ãƒãƒ¼ãƒ è²¢çŒ®åº¦ã€å®Œæˆåº¦ | ã€Œã¿ã‚“ãªã§åŸã‚’å»ºã¦ã‚ˆã†ã€ |

### Challenge ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

```java
public class Challenge {
    private String challengeId;
    private String title;
    private String description;
    private ChallengeType type;
    private DifficultyLevel difficulty;
    private int timeLimit;                    // åˆ¶é™æ™‚é–“ï¼ˆç§’ã€0=ç„¡åˆ¶é™ï¼‰
    private List<CriteriaDefinition> criteria; // è©•ä¾¡åŸºæº–
    private int maxScore;                     // æœ€é«˜ç‚¹
    private String assignedBy;                // å‰²ã‚Šå½“ã¦æ•™å¸«ID
    private LocalDateTime deadline;           // ç· åˆ‡
    private ChallengeResources resources;     // ãƒªã‚½ãƒ¼ã‚¹ï¼ˆèª¬æ˜ç”»åƒç­‰ï¼‰
}

public enum ChallengeType {
    BUILD("å»ºç¯‰èª²é¡Œ"),
    PROGRAMMING("ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°èª²é¡Œ"),
    EXPLORATION("æ¢ç´¢èª²é¡Œ"),
    CREATIVE("å‰µé€ èª²é¡Œ"),
    COLLABORATIVE("å”åƒèª²é¡Œ");

    private final String displayName;
}

public class CriteriaDefinition {
    private String criteriaId;
    private String name;                      // åŸºæº–å
    private CriteriaType type;                // åŸºæº–ã‚¿ã‚¤ãƒ—
    private int weight;                       // é…ç‚¹
    private Map<String, Object> params;       // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    private boolean autoEvaluated;            // è‡ªå‹•è©•ä¾¡å¯èƒ½ã‹
}

public enum CriteriaType {
    BLOCK_COUNT,           // ãƒ–ãƒ­ãƒƒã‚¯æ•°
    STRUCTURE_MATCH,       // æ§‹é€ ä¸€è‡´åº¦
    CODE_EFFICIENCY,       // ã‚³ãƒ¼ãƒ‰åŠ¹ç‡
    CODE_LENGTH,           // ã‚³ãƒ¼ãƒ‰è¡Œæ•°
    TIME_TAKEN,            // æ‰€è¦æ™‚é–“
    CREATIVITY,            // å‰µé€ æ€§ï¼ˆæ‰‹å‹•è©•ä¾¡ï¼‰
    TECHNICAL_SKILL,       // æŠ€è¡“åŠ›ï¼ˆæ‰‹å‹•è©•ä¾¡ï¼‰
    COMPLETENESS           // å®Œæˆåº¦ï¼ˆæ‰‹å‹•è©•ä¾¡ï¼‰
}
```

### ChallengeSystemï¼ˆJavaå®Ÿè£…ï¼‰

```java
public class ChallengeSystem {

    private final Map<String, Challenge> challenges;
    private final Map<String, ChallengeSubmission> submissions;
    private final AutoEvaluator autoEvaluator;
    private final EventBroadcaster broadcaster;

    /**
     * èª²é¡Œå‰²ã‚Šå½“ã¦ï¼ˆæ•™å¸«ç”¨ï¼‰
     */
    public AssignmentResult assignChallenge(
        ClientSession teacherSession,
        String challengeId,
        List<String> studentIds,
        LocalDateTime deadline
    ) {
        // æ¨©é™ãƒã‚§ãƒƒã‚¯
        if (teacherSession.getRole() != Role.TEACHER) {
            return AssignmentResult.error("æ•™å¸«ã®ã¿ãŒèª²é¡Œã‚’å‰²ã‚Šå½“ã¦ã§ãã¾ã™");
        }

        Challenge challenge = challenges.get(challengeId);
        if (challenge == null) {
            return AssignmentResult.error("èª²é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        }

        // å„ç”Ÿå¾’ã«å‰²ã‚Šå½“ã¦
        for (String studentId : studentIds) {
            ChallengeAssignment assignment = new ChallengeAssignment(
                UUID.randomUUID().toString(),
                challengeId,
                studentId,
                teacherSession.getClientId(),
                deadline
            );

            // é€šçŸ¥é€ä¿¡
            broadcaster.sendToUser(
                studentId,
                new ChallengeAssignedNotification(challenge, deadline)
            );
        }

        return AssignmentResult.success(studentIds.size());
    }

    /**
     * èª²é¡Œæå‡º
     */
    public SubmissionResult submitChallenge(
        ClientSession studentSession,
        String challengeId,
        ChallengeWork work
    ) {
        Challenge challenge = challenges.get(challengeId);
        if (challenge == null) {
            return SubmissionResult.error("èª²é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        }

        // æå‡ºç‰©ä½œæˆ
        ChallengeSubmission submission = new ChallengeSubmission(
            UUID.randomUUID().toString(),
            challengeId,
            studentSession.getClientId(),
            LocalDateTime.now(),
            work
        );

        // è‡ªå‹•è©•ä¾¡
        AutoEvaluationResult autoResult = autoEvaluator.evaluate(challenge, work);
        submission.setAutoScore(autoResult.getScore());
        submission.setAutoFeedback(autoResult.getFeedback());

        // æ‰‹å‹•è©•ä¾¡ãŒå¿…è¦ãªåŸºæº–ãŒã‚ã‚‹ã‹ç¢ºèª
        boolean needsManualGrading = challenge.getCriteria().stream()
            .anyMatch(c -> !c.isAutoEvaluated());

        if (needsManualGrading) {
            submission.setStatus(SubmissionStatus.PENDING_REVIEW);

            // æ•™å¸«ã«é€šçŸ¥
            broadcaster.sendToUser(
                challenge.getAssignedBy(),
                new SubmissionPendingNotification(studentSession, challenge)
            );
        } else {
            submission.setStatus(SubmissionStatus.GRADED);
            submission.setFinalScore(autoResult.getScore());
        }

        submissions.put(submission.getSubmissionId(), submission);

        return SubmissionResult.success(submission, autoResult);
    }

    /**
     * æ•™å¸«è©•ä¾¡
     */
    public GradingResult gradeSubmission(
        ClientSession teacherSession,
        String submissionId,
        Map<String, Integer> manualScores,
        String feedback
    ) {
        if (teacherSession.getRole() != Role.TEACHER) {
            return GradingResult.error("æ•™å¸«ã®ã¿ãŒè©•ä¾¡ã§ãã¾ã™");
        }

        ChallengeSubmission submission = submissions.get(submissionId);
        if (submission == null) {
            return GradingResult.error("æå‡ºç‰©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        }

        // æ‰‹å‹•è©•ä¾¡ã‚¹ã‚³ã‚¢è¨­å®š
        submission.setManualScores(manualScores);
        submission.setTeacherFeedback(feedback);

        // æœ€çµ‚ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆè‡ªå‹•è©•ä¾¡ + æ‰‹å‹•è©•ä¾¡ï¼‰
        int finalScore = calculateFinalScore(
            submission.getChallenge(),
            submission.getAutoScore(),
            manualScores
        );

        submission.setFinalScore(finalScore);
        submission.setStatus(SubmissionStatus.GRADED);
        submission.setGradedAt(LocalDateTime.now());
        submission.setGradedBy(teacherSession.getClientId());

        // ç”Ÿå¾’ã«é€šçŸ¥
        broadcaster.sendToUser(
            submission.getStudentId(),
            new GradingCompletedNotification(submission, finalScore, feedback)
        );

        return GradingResult.success(finalScore);
    }

    /**
     * æœ€çµ‚ã‚¹ã‚³ã‚¢è¨ˆç®—
     */
    private int calculateFinalScore(
        Challenge challenge,
        Map<String, Integer> autoScores,
        Map<String, Integer> manualScores
    ) {
        int totalScore = 0;
        int totalWeight = 0;

        for (CriteriaDefinition criteria : challenge.getCriteria()) {
            int score = criteria.isAutoEvaluated()
                ? autoScores.getOrDefault(criteria.getCriteriaId(), 0)
                : manualScores.getOrDefault(criteria.getCriteriaId(), 0);

            totalScore += score * criteria.getWeight();
            totalWeight += criteria.getWeight();
        }

        return totalWeight > 0 ? (totalScore * 100) / totalWeight : 0;
    }
}
```

### AutoEvaluator

```java
public class AutoEvaluator {

    /**
     * è‡ªå‹•è©•ä¾¡å®Ÿè¡Œ
     */
    public AutoEvaluationResult evaluate(Challenge challenge, ChallengeWork work) {
        Map<String, Integer> scores = new HashMap<>();
        List<String> feedback = new ArrayList<>();

        for (CriteriaDefinition criteria : challenge.getCriteria()) {
            if (!criteria.isAutoEvaluated()) {
                continue;
            }

            CriteriaEvaluationResult result = evaluateCriteria(criteria, work);
            scores.put(criteria.getCriteriaId(), result.getScore());
            feedback.add(result.getFeedback());
        }

        int totalScore = scores.values().stream()
            .mapToInt(Integer::intValue)
            .sum();

        return new AutoEvaluationResult(scores, totalScore, feedback);
    }

    private CriteriaEvaluationResult evaluateCriteria(
        CriteriaDefinition criteria,
        ChallengeWork work
    ) {
        switch (criteria.getType()) {
            case BLOCK_COUNT:
                return evaluateBlockCount(criteria, work);

            case CODE_LENGTH:
                return evaluateCodeLength(criteria, work);

            case CODE_EFFICIENCY:
                return evaluateCodeEfficiency(criteria, work);

            case STRUCTURE_MATCH:
                return evaluateStructureMatch(criteria, work);

            case TIME_TAKEN:
                return evaluateTimeTaken(criteria, work);

            default:
                return CriteriaEvaluationResult.zero("è‡ªå‹•è©•ä¾¡ä¸å¯");
        }
    }

    private CriteriaEvaluationResult evaluateBlockCount(
        CriteriaDefinition criteria,
        ChallengeWork work
    ) {
        int targetCount = (int) criteria.getParams().get("targetCount");
        int tolerance = (int) criteria.getParams().getOrDefault("tolerance", 0);
        int actualCount = work.getBlockCount();

        int diff = Math.abs(actualCount - targetCount);

        if (diff <= tolerance) {
            return CriteriaEvaluationResult.full(
                criteria.getWeight(),
                String.format("ãƒ–ãƒ­ãƒƒã‚¯æ•°å®Œç’§ï¼ï¼ˆ%då€‹ï¼‰", actualCount)
            );
        } else if (diff <= tolerance * 2) {
            int score = (int) (criteria.getWeight() * 0.7);
            return new CriteriaEvaluationResult(
                score,
                String.format("ãƒ–ãƒ­ãƒƒã‚¯æ•°ãŒã‚„ã‚„ç•°ãªã‚Šã¾ã™ï¼ˆç›®æ¨™:%d, å®Ÿéš›:%dï¼‰", targetCount, actualCount)
            );
        } else {
            int score = (int) (criteria.getWeight() * 0.3);
            return new CriteriaEvaluationResult(
                score,
                String.format("ãƒ–ãƒ­ãƒƒã‚¯æ•°ãŒå¤§ããç•°ãªã‚Šã¾ã™ï¼ˆç›®æ¨™:%d, å®Ÿéš›:%dï¼‰", targetCount, actualCount)
            );
        }
    }

    private CriteriaEvaluationResult evaluateCodeLength(
        CriteriaDefinition criteria,
        ChallengeWork work
    ) {
        int maxLines = (int) criteria.getParams().get("maxLines");
        int actualLines = work.getScratchCode().getBlockCount();

        if (actualLines <= maxLines) {
            return CriteriaEvaluationResult.full(
                criteria.getWeight(),
                String.format("ã‚³ãƒ¼ãƒ‰è¡Œæ•°: %dè¡Œï¼ˆç›®æ¨™:%dè¡Œä»¥å†…ï¼‰âœ“", actualLines, maxLines)
            );
        } else {
            int penalty = Math.min(actualLines - maxLines, criteria.getWeight());
            int score = Math.max(0, criteria.getWeight() - penalty);
            return new CriteriaEvaluationResult(
                score,
                String.format("ã‚³ãƒ¼ãƒ‰ãŒé•·ã™ãã¾ã™ï¼ˆ%dè¡Œã€ç›®æ¨™:%dè¡Œä»¥å†…ï¼‰", actualLines, maxLines)
            );
        }
    }

    // ... ãã®ä»–ã®è©•ä¾¡ãƒ¡ã‚½ãƒƒãƒ‰
}
```

---

## é€²æ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ProgressTracker

```java
public class ProgressTracker {

    private final Map<String, UserProgress> userProgressMap;
    private final DataPersistenceService persistenceService;

    /**
     * é€²æ—è¨˜éŒ²
     */
    public void recordAction(ClientSession session, PlayerAction action) {
        UserProgress progress = getOrCreateProgress(session.getClientId());

        switch (action.getType()) {
            case PLACE_BLOCK:
                progress.incrementBlocksPlaced();
                progress.recordBlockType(action.getBlockType());
                break;

            case SUMMON_ENTITY:
                progress.incrementEntitiesSummoned();
                break;

            case CHAT:
                progress.incrementChatMessages();
                break;

            // ... ãã®ä»–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        }

        progress.setLastActivity(LocalDateTime.now());
        persistenceService.save(progress);

        // ãƒãƒƒã‚¸ãƒã‚§ãƒƒã‚¯
        checkAndAwardBadges(session, progress);
    }

    /**
     * é€²æ—å–å¾—
     */
    public UserProgress getProgress(String userId) {
        return userProgressMap.getOrDefault(
            userId,
            new UserProgress(userId)
        );
    }

    /**
     * ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
     */
    public ProgressReport generateReport(String userId, DateRange range) {
        UserProgress progress = getProgress(userId);

        return ProgressReport.builder()
            .userId(userId)
            .dateRange(range)
            .tutorialsCompleted(progress.getCompletedTutorials().size())
            .challengesCompleted(progress.getCompletedChallenges().size())
            .totalPoints(progress.getTotalPoints())
            .blocksPlaced(progress.getBlocksPlaced())
            .entitiesSummoned(progress.getEntitiesSummoned())
            .badges(progress.getEarnedBadges())
            .activityTimeline(progress.getActivityTimeline(range))
            .blockUsageStats(progress.getBlockUsageStats())
            .build();
    }

    private UserProgress getOrCreateProgress(String userId) {
        return userProgressMap.computeIfAbsent(
            userId,
            id -> new UserProgress(id)
        );
    }
}
```

### UserProgress ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

```java
public class UserProgress {
    private String userId;
    private int totalPoints;
    private int blocksPlaced;
    private int entitiesSummoned;
    private int chatMessages;
    private Set<String> completedTutorials;
    private Set<String> completedChallenges;
    private Set<String> earnedBadges;
    private Map<String, Integer> blockUsageStats;
    private LocalDateTime lastActivity;
    private LocalDateTime joinedAt;

    // ãƒ¡ã‚½ãƒƒãƒ‰
    public void incrementBlocksPlaced() {
        this.blocksPlaced++;
    }

    public void recordBlockType(String blockType) {
        blockUsageStats.merge(blockType, 1, Integer::sum);
    }

    public void addPoints(int points) {
        this.totalPoints += points;
    }

    public void awardBadge(String badgeId) {
        this.earnedBadges.add(badgeId);
    }

    // ... ãã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰
}
```

---

## ãƒãƒƒã‚¸ãƒ»é”æˆã‚·ã‚¹ãƒ†ãƒ 

### ãƒãƒƒã‚¸å®šç¾©

```json
{
  "badges": [
    {
      "badgeId": "connected",
      "name": "æ¥ç¶šãƒã‚¹ã‚¿ãƒ¼",
      "description": "åˆã‚ã¦Minecraftã«æ¥ç¶šã—ãŸ",
      "iconUrl": "/assets/badges/connected.png",
      "rarity": "COMMON",
      "trigger": {
        "type": "CONNECTION_ESTABLISHED",
        "count": 1
      }
    },
    {
      "badgeId": "first_chat",
      "name": "ãŠã—ã‚ƒã¹ã‚Šåˆå¿ƒè€…",
      "description": "åˆã‚ã¦ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ãŸ",
      "iconUrl": "/assets/badges/first_chat.png",
      "rarity": "COMMON",
      "trigger": {
        "type": "CHAT_MESSAGE",
        "count": 1
      }
    },
    {
      "badgeId": "builder_100",
      "name": "å»ºç¯‰å®¶è¦‹ç¿’ã„",
      "description": "100å€‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®ã—ãŸ",
      "iconUrl": "/assets/badges/builder_100.png",
      "rarity": "UNCOMMON",
      "trigger": {
        "type": "BLOCKS_PLACED",
        "count": 100
      }
    },
    {
      "badgeId": "builder_1000",
      "name": "å»ºç¯‰ãƒã‚¹ã‚¿ãƒ¼",
      "description": "1000å€‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®ã—ãŸ",
      "iconUrl": "/assets/badges/builder_1000.png",
      "rarity": "RARE",
      "trigger": {
        "type": "BLOCKS_PLACED",
        "count": 1000
      }
    },
    {
      "badgeId": "tutorial_master",
      "name": "ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«åˆ¶è¦‡",
      "description": "ã™ã¹ã¦ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’å®Œäº†ã—ãŸ",
      "iconUrl": "/assets/badges/tutorial_master.png",
      "rarity": "EPIC",
      "trigger": {
        "type": "TUTORIALS_COMPLETED",
        "count": "ALL"
      }
    },
    {
      "badgeId": "speedster",
      "name": "ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚¿ãƒ¼",
      "description": "èª²é¡Œã‚’5åˆ†ä»¥å†…ã«ã‚¯ãƒªã‚¢ã—ãŸ",
      "iconUrl": "/assets/badges/speedster.png",
      "rarity": "RARE",
      "trigger": {
        "type": "CHALLENGE_TIME",
        "maxSeconds": 300
      }
    },
    {
      "badgeId": "perfectionist",
      "name": "å®Œç’§ä¸»ç¾©è€…",
      "description": "èª²é¡Œã§æº€ç‚¹ã‚’ç²å¾—ã—ãŸ",
      "iconUrl": "/assets/badges/perfectionist.png",
      "rarity": "EPIC",
      "trigger": {
        "type": "CHALLENGE_SCORE",
        "minScore": 100
      }
    },
    {
      "badgeId": "creative_genius",
      "name": "å‰µé€ ã®å¤©æ‰",
      "description": "å‰µé€ èª²é¡Œã§æœ€é«˜è©•ä¾¡ã‚’ç²å¾—ã—ãŸ",
      "iconUrl": "/assets/badges/creative_genius.png",
      "rarity": "LEGENDARY",
      "trigger": {
        "type": "CREATIVE_RATING",
        "minRating": 5
      }
    }
  ]
}
```

### BadgeManager

```java
public class BadgeManager {

    private final Map<String, Badge> badges;
    private final EventBroadcaster broadcaster;

    /**
     * ãƒãƒƒã‚¸ãƒã‚§ãƒƒã‚¯ã¨ä»˜ä¸
     */
    public void checkAndAward(ClientSession session, UserProgress progress) {
        for (Badge badge : badges.values()) {
            if (progress.getEarnedBadges().contains(badge.getBadgeId())) {
                continue; // æ—¢ã«ç²å¾—æ¸ˆã¿
            }

            if (isTriggerMet(badge.getTrigger(), progress)) {
                awardBadge(session, progress, badge);
            }
        }
    }

    private boolean isTriggerMet(BadgeTrigger trigger, UserProgress progress) {
        switch (trigger.getType()) {
            case BLOCKS_PLACED:
                return progress.getBlocksPlaced() >= trigger.getCount();

            case CHAT_MESSAGE:
                return progress.getChatMessages() >= trigger.getCount();

            case TUTORIALS_COMPLETED:
                if ("ALL".equals(trigger.getCount())) {
                    return progress.getCompletedTutorials().size() >= getTotalTutorials();
                } else {
                    return progress.getCompletedTutorials().size() >= (int) trigger.getCount();
                }

            // ... ãã®ä»–ã®ãƒˆãƒªã‚¬ãƒ¼

            default:
                return false;
        }
    }

    private void awardBadge(ClientSession session, UserProgress progress, Badge badge) {
        progress.awardBadge(badge.getBadgeId());

        broadcaster.sendToClient(
            session,
            new BadgeAwardedNotification(badge)
        );

        // ãƒ­ã‚°è¨˜éŒ²
        System.out.println(String.format(
            "Badge awarded: %s to user %s",
            badge.getName(),
            session.getClientName()
        ));
    }
}
```

---

## UI/UXè¨­è¨ˆ

### Scratchã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´UI

#### ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒ‘ãƒãƒ«

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“š ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«                         [é–‰ã˜ã‚‹] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ã‚¹ãƒ†ãƒƒãƒ— 2/4: Minecraftã«æ¥ç¶šã—ã‚ˆã†              â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”    â”‚
â”‚                                                      â”‚
â”‚  ã€ŒMinecraftã«æ¥ç¶šã€ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«       â”‚
â”‚  ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã€ç·‘ã®æ——ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚       â”‚
â”‚                                                      â”‚
â”‚  [ç”»åƒ: æ¥ç¶šãƒ–ãƒ­ãƒƒã‚¯ã®ä¾‹]                           â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ ãƒ’ãƒ³ãƒˆ: ãƒ›ã‚¹ãƒˆã¯ã€Œlocalhostã€ã€ãƒãƒ¼ãƒˆã¯         â”‚
â”‚  ã€Œ14711ã€ã®ã¾ã¾ã§OKã§ã™ã€‚                          â”‚
â”‚                                                      â”‚
â”‚              [å‰ã®ã‚¹ãƒ†ãƒƒãƒ—] [ãƒ’ãƒ³ãƒˆã‚’è¦‹ã‚‹]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### é€²æ—ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“Š ãƒã‚¤é€²æ—                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ç·ãƒã‚¤ãƒ³ãƒˆ: 1,250 pt  ğŸ† ãƒãƒƒã‚¸: 8å€‹              â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ« â”‚  â”‚   èª²é¡Œ      â”‚                â”‚
â”‚  â”‚   5/10å®Œäº†   â”‚  â”‚   3/5å®Œäº†   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                      â”‚
â”‚  æœ€è¿‘ã®æ´»å‹•:                                         â”‚
â”‚  â€¢ ãƒ–ãƒ­ãƒƒã‚¯é…ç½®: 250å€‹                              â”‚
â”‚  â€¢ ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å¬å–š: 15å›                           â”‚
â”‚  â€¢ ãƒãƒ£ãƒƒãƒˆé€ä¿¡: 42å›                               â”‚
â”‚                                                      â”‚
â”‚  ç²å¾—ãƒãƒƒã‚¸:                                         â”‚
â”‚  ğŸ… æ¥ç¶šãƒã‚¹ã‚¿ãƒ¼  ğŸ… ãŠã—ã‚ƒã¹ã‚Šåˆå¿ƒè€…              â”‚
â”‚  ğŸ… å»ºç¯‰å®¶è¦‹ç¿’ã„  ğŸ… ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚¿ãƒ¼                â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¬ã‚¤ãƒ‰

### ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä½œæˆæ‰‹é †

1. **ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š**: å¯¾è±¡è€…ï¼ˆåˆå¿ƒè€…/ä¸­ç´šè€…/ä¸Šç´šè€…ï¼‰ã‚’æ˜ç¢ºåŒ–
2. **ç›®æ¨™å®šç¾©**: ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«å®Œäº†å¾Œã«ç¿’å¾—ã§ãã‚‹ã‚¹ã‚­ãƒ«ã‚’å®šç¾©
3. **ã‚¹ãƒ†ãƒƒãƒ—åˆ†å‰²**: å¤§ããªç›®æ¨™ã‚’å°ã•ãªã‚¹ãƒ†ãƒƒãƒ—ã«åˆ†å‰²ï¼ˆç†æƒ³: 4-8ã‚¹ãƒ†ãƒƒãƒ—ï¼‰
4. **æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ä½œæˆ**: å„ã‚¹ãƒ†ãƒƒãƒ—ã§ä½•ã‚’ç¢ºèªã™ã‚‹ã‹å®šç¾©
5. **ãƒ’ãƒ³ãƒˆæº–å‚™**: è©°ã¾ã£ãŸæ™‚ã®ãƒ’ãƒ³ãƒˆã‚’æº–å‚™
6. **ãƒ†ã‚¹ãƒˆ**: å®Ÿéš›ã«ãƒ—ãƒ¬ã‚¤ã—ã¦é›£æ˜“åº¦ã‚’ç¢ºèª

### ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

```json
{
  "tutorialId": "custom_XXX",
  "title": "[ã‚¿ã‚¤ãƒˆãƒ«]",
  "description": "[èª¬æ˜]",
  "difficulty": "BEGINNER/INTERMEDIATE/ADVANCED",
  "estimatedMinutes": 15,
  "prerequisites": [],
  "steps": [
    {
      "stepId": 1,
      "title": "[ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¤ãƒˆãƒ«]",
      "instruction": "[å…·ä½“çš„ãªæŒ‡ç¤º]",
      "hint": "[ãƒ’ãƒ³ãƒˆ]",
      "validation": {
        "type": "é©åˆ‡ãªã‚¿ã‚¤ãƒ—ã‚’é¸æŠ",
        "params": {}
      },
      "reward": {
        "points": 10,
        "message": "[åŠ±ã¾ã—ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸]"
      }
    }
  ]
}
```

---

**ä½œæˆæ—¥**: 2025-11-12
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0.0
